<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <meta name="applicable-device" content="pc,mobile">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2">
</head>
<body>

    <div id="app">promise</div>
    
    <script type="text/javascript" >
        // 1. 什么是回调地狱? 
        // 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件
        // 2. 回调地狱的缺点? 
        // 不便于阅读
        // 不便于异常处理
        // 3. 解决方案?
        // promise 链式调用
        // 4. 终极解决方案?
        // async/await

        // 1. Promise 构造函数: Promise (excutor) {}
        // (1) executor 函数: 执行器 (resolve, reject) => {} 
        // (2) resolve 函数: 内部定义成功时我们调用的函数 value => {}
        // (3) reject 函数: 内部定义失败时我们调用的函数 reason => {}
        // 说明: executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行

        // 2. Promise.prototype.then 方法: (onResolved, onRejected) => {}
        // (1) onResolved 函数: 成功的回调函数 (value) => {}
        // (2) onRejected 函数: 失败的回调函数 (reason) => {}
        // 说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调
        // 返回一个新的 promise 对象

        // 3. Promise.prototype.catch 方法: (onRejected) => {}
        // (1) onRejected 函数: 失败的回调函数 (reason) => {}
        // 说明: then()的语法糖, 相当于: then(undefined, onRejected)

        // 4. Promise.resolve 方法: (value) => {}
        // (1) value: 成功的数据或 promise 对象
        // 说明: 返回一个成功/失败的 promise 对象

        // 5. Promise.reject 方法: (reason) => {}
        // (1) reason: 失败的原因
        // 说明: 返回一个失败的 promise 对象

        // 6. Promise.all 方法: (promises) => {}
        // (1) promises: 包含 n 个 promise 的数组
        // 说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一个失败了就
        // 直接失败
        
        // 7. Promise.race 方法: (promises) => {}
        // (1) promises: 包含 n 个 promise 的数组
        // 说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态


    </script>

</body>
</html>